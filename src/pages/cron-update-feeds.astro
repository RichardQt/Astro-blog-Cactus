---
// CRON 任务页面 - 用于定时更新 RSS feeds
// 访问路径: /cron-update-feeds?secret=sk-123456

import { defaultRSSConfig } from "@/utils/rss";
import type { RSSSource, RSSFeed } from "@/types";
import { XMLParser } from 'fast-xml-parser';

export const prerender = false;

// 验证密钥
const secret = Astro.url.searchParams.get('secret');
const expectedSecret = import.meta.env.CRON_SECRET || 'sk-123456';

if (import.meta.env.PROD && secret !== expectedSecret) {
  return new Response(JSON.stringify({
    error: '未授权的请求',
  }), {
    status: 401,
    headers: { 'Content-Type': 'application/json' },
  });
}

// 动态导入 Redis 以避免构建问题
let redis: any = null;
let redisDebugInfo = {
  hasUrl: !!import.meta.env.UPSTASH_REDIS_REST_URL,
  hasToken: !!import.meta.env.UPSTASH_REDIS_REST_TOKEN,
  urlPrefix: import.meta.env.UPSTASH_REDIS_REST_URL ? import.meta.env.UPSTASH_REDIS_REST_URL.substring(0, 20) + '...' : 'not set',
  tokenPrefix: import.meta.env.UPSTASH_REDIS_REST_TOKEN ? import.meta.env.UPSTASH_REDIS_REST_TOKEN.substring(0, 10) + '...' : 'not set',
};

console.log('[CRON] Redis 环境变量状态:', redisDebugInfo);

try {
  if (import.meta.env.UPSTASH_REDIS_REST_URL && import.meta.env.UPSTASH_REDIS_REST_TOKEN) {
    const { Redis } = await import('@upstash/redis');
    redis = new Redis({
      url: import.meta.env.UPSTASH_REDIS_REST_URL,
      token: import.meta.env.UPSTASH_REDIS_REST_TOKEN,
    });
    console.log('[CRON] Upstash Redis 已初始化成功');
  } else {
    console.log('[CRON] Redis 环境变量未配置');
  }
} catch (error) {
  console.error('[CRON] Redis 初始化失败:', error);
}

// 带超时的 fetch
async function fetchWithTimeout(url: string, timeout: number = 3000): Promise<Response> {
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), timeout);
  
  try {
    const response = await fetch(url, {
      signal: controller.signal,
      headers: {
        'User-Agent': 'Mozilla/5.0 (compatible; RSS Reader)',
        'Accept': 'application/rss+xml, application/xml, text/xml',
      },
    });
    clearTimeout(timeoutId);
    return response;
  } catch (error) {
    clearTimeout(timeoutId);
    throw error;
  }
}

// 解析单个RSS源
async function fetchSingleSource(source: RSSSource): Promise<RSSFeed | null> {
  try {
    console.log(`[CRON] 开始获取: ${source.name}`);
    const response = await fetchWithTimeout(source.url, 3000);
    
    if (!response.ok) {
      console.error(`[CRON] RSS源 ${source.name} 请求失败: ${response.status}`);
      return null;
    }

    const xmlText = await response.text();
    
    const parser = new XMLParser({
      ignoreAttributes: false,
      attributeNamePrefix: "@_",
      textNodeName: "#text",
      parseAttributeValue: true,
      parseTagValue: true,
      trimValues: true,
    });

    const result = parser.parse(xmlText);
    const rss = result.rss || result.feed;
    
    if (!rss) {
      console.error(`[CRON] RSS源 ${source.name} 格式无效`);
      return null;
    }

    const channel = rss.channel || rss;
    const itemElements = channel.item || channel.entry || [];
    const itemsArray = Array.isArray(itemElements) ? itemElements : [itemElements];
    
    const items = itemsArray.slice(0, 30).map((item: any, index: number) => {
      const title = item.title?.['#text'] || item.title || '';
      const description = item.description?.['#text'] || item.description || item.summary || '';
      const link = item.link?.['#text'] || item.link || '';
      const pubDate = item.pubDate || item.published || item.updated || new Date().toISOString();
      
      const cleanDescription = typeof description === 'string' 
        ? description.replace(/<[^>]*>/g, '').trim().slice(0, 500) 
        : '';
      
      return {
        id: `${source.id}-${index}`,
        title: typeof title === 'string' ? title.trim().slice(0, 300) : '',
        description: cleanDescription,
        content: description,
        link: typeof link === 'string' ? link.trim() : '',
        pubDate,
        sourceId: source.id,
        sourceName: source.name,
        read: false,
      };
    }).filter((item: any) => item.title && item.link);

    return {
      source,
      items,
      lastBuildDate: channel.lastBuildDate || new Date().toISOString(),
    };
  } catch (error) {
    console.error(`[CRON] 获取RSS源 ${source.name} 失败:`, error);
    return null;
  }
}

// 执行 CRON 任务
console.log('[CRON] 开始更新 RSS feeds...');
const startTime = Date.now();

// 获取所有源
const sources = defaultRSSConfig.sources;

// 分批处理源，避免并发过多
const BATCH_SIZE = 3; // 每批处理3个源
const results = [];

for (let i = 0; i < sources.length; i += BATCH_SIZE) {
  const batch = sources.slice(i, i + BATCH_SIZE);
  const batchPromises = batch.map(source => fetchSingleSource(source));
  const batchResults = await Promise.allSettled(batchPromises);
  results.push(...batchResults);
  
  // 批次之间稍微延迟，避免过快请求
  if (i + BATCH_SIZE < sources.length) {
    await new Promise(resolve => setTimeout(resolve, 100));
  }
}

const feeds: RSSFeed[] = [];
const errors: string[] = [];

results.forEach((result, index) => {
  if (result.status === 'fulfilled' && result.value) {
    feeds.push(result.value);
  } else {
    const sourceName = sources[index]?.name || `源 ${index + 1}`;
    errors.push(`${sourceName}: 获取失败`);
  }
});

const duration = Date.now() - startTime;

// 保存到 Redis
let saved = false;
if (redis) {
  try {
    const cacheData = {
      feeds,
      errors,
      stats: {
        total: sources.length,
        successful: feeds.length,
        failed: errors.length,
        duration,
        fromCache: false,
        lastUpdate: new Date().toISOString(),
      },
      timestamp: new Date().toISOString(),
    };
    
    // 缓存主数据
    await redis.setex('rss-all-feeds', 7200, JSON.stringify(cacheData)); // 2小时过期
    
    // 也缓存每个源的数据，方便单独页面使用
    for (const feed of feeds) {
      const feedKey = `rss-feed-${feed.source.id}`;
      await redis.setex(feedKey, 7200, JSON.stringify(feed)); // 2小时过期
    }
    
    // 保存更新日志供 /api/rss-status 使用
    const updateLog = {
      timestamp: new Date().toISOString(),
      duration,
      stats: cacheData.stats,
      sources: feeds.map(f => ({
        id: f.source.id,
        name: f.source.name,
        items: f.items.length
      }))
    };
    await redis.setex('rss-update-log', 86400, JSON.stringify(updateLog)); // 24小时过期
    
    saved = true;
    console.log('[CRON] 数据已保存到 Redis');
  } catch (error) {
    console.error('[CRON] 保存到 Redis 失败:', error);
  }
}

const response = {
  success: true,
  message: `CRON任务完成，更新了 ${feeds.length}/${sources.length} 个RSS源`,
  stats: {
    total: sources.length,
    successful: feeds.length,
    failed: errors.length,
    duration,
    saved,
  },
  redis: {
    configured: !!redis,
    debug: redisDebugInfo
  },
  errors: errors.length > 0 ? errors : undefined,
  timestamp: new Date().toISOString(),
};

console.log(`[CRON] 任务完成，耗时: ${duration}ms，成功: ${feeds.length}/${sources.length}`);
---

<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>CRON Update Status</title>
</head>
<body style="font-family: monospace; padding: 20px; background: #1a1a1a; color: #0f0;">
  <h1>CRON Update Status</h1>
  <pre>{JSON.stringify(response, null, 2)}</pre>
</body>
</html>
