---
// RSSè®¢é˜…æºä¸»é¡µé¢
// æ˜¾ç¤ºæ‰€æœ‰å¯ç”¨çš„RSSè®¢é˜…æº

import { defaultRSSConfig } from "@/utils/rss";
import type { RSSSource, RSSFeed } from "@/types";
import RSSFeedTable from "@/components/rss/RSSFeedTable.astro";
import PageLayout from "@/layouts/Base.astro";
// import { Icon } from "astro-icon/components";
import { XMLParser } from 'fast-xml-parser';

export const prerender = false; // æ”¹ä¸ºfalseä»¥æ”¯æŒåŠ¨æ€URLå‚æ•°

// åŠ¨æ€å¯¼å…¥ Upstash Redis ä»¥é¿å…æ„å»ºé—®é¢˜
let redis: any = null;
try {
  if (import.meta.env.UPSTASH_REDIS_REST_URL && import.meta.env.UPSTASH_REDIS_REST_TOKEN) {
    const { Redis } = await import('@upstash/redis');
    redis = new Redis({
      url: import.meta.env.UPSTASH_REDIS_REST_URL,
      token: import.meta.env.UPSTASH_REDIS_REST_TOKEN,
    });
    console.log('Rediså·²åˆå§‹åŒ–');
  }
} catch (error) {
  console.error('Redisåˆå§‹åŒ–å¤±è´¥:', error);
}

// å†…å­˜ç¼“å­˜
const memoryCache = new Map<string, { data: any; timestamp: number }>();
const CACHE_DURATION = 5 * 60 * 1000; // 5åˆ†é’Ÿ

// è·å–ç¼“å­˜
async function getCachedData(key: string): Promise<any | null> {
  // å…ˆå°è¯• Redis
  if (redis) {
    try {
      const data = await redis.get(key);
      if (data) return typeof data === 'string' ? JSON.parse(data) : data;
    } catch (error) {
      console.error('Redisè¯»å–å¤±è´¥:', error);
    }
  }
  
  // é™çº§åˆ°å†…å­˜ç¼“å­˜
  const cached = memoryCache.get(key);
  if (cached && Date.now() - cached.timestamp < CACHE_DURATION) {
    return cached.data;
  }
  
  return null;
}

// è®¾ç½®ç¼“å­˜
async function setCachedData(key: string, data: any): Promise<void> {
  // ä¿å­˜åˆ° Redis
  if (redis) {
    try {
      await redis.setex(key, 300, JSON.stringify(data)); // 5åˆ†é’Ÿè¿‡æœŸ
    } catch (error) {
      console.error('Rediså†™å…¥å¤±è´¥:', error);
    }
  }
  
  // åŒæ—¶ä¿å­˜åˆ°å†…å­˜
  memoryCache.set(key, { data, timestamp: Date.now() });
}

// å¸¦è¶…æ—¶çš„ fetch
async function fetchWithTimeout(url: string, timeout: number = 3000): Promise<Response> {
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), timeout);
  
  try {
    const response = await fetch(url, {
      signal: controller.signal,
      headers: {
        'User-Agent': 'Mozilla/5.0 (compatible; RSS Reader)',
        'Accept': 'application/rss+xml, application/xml, text/xml',
      },
    });
    clearTimeout(timeoutId);
    return response;
  } catch (error) {
    clearTimeout(timeoutId);
    throw error;
  }
}

// è§£æå•ä¸ªRSSæº
async function fetchSingleSource(source: RSSSource): Promise<RSSFeed | null> {
  try {
    const response = await fetchWithTimeout(source.url, 3000);
    
    if (!response.ok) {
      console.error(`RSSæº ${source.name} è¯·æ±‚å¤±è´¥: ${response.status}`);
      return null;
    }

    const xmlText = await response.text();
    
    const parser = new XMLParser({
      ignoreAttributes: false,
      attributeNamePrefix: "@_",
      textNodeName: "#text",
      parseAttributeValue: true,
      parseTagValue: true,
      trimValues: true,
    });

    const result = parser.parse(xmlText);
    const rss = result.rss || result.feed;
    
    if (!rss) {
      console.error(`RSSæº ${source.name} æ ¼å¼æ— æ•ˆ`);
      return null;
    }

    const channel = rss.channel || rss;
    const itemElements = channel.item || channel.entry || [];
    const itemsArray = Array.isArray(itemElements) ? itemElements : [itemElements];
    
    const items = itemsArray.slice(0, 20).map((item: any, index: number) => {
      const title = item.title?.['#text'] || item.title || '';
      const description = item.description?.['#text'] || item.description || item.summary || '';
      const link = item.link?.['#text'] || item.link || '';
      const pubDate = item.pubDate || item.published || item.updated || new Date().toISOString();
      
      return {
        id: `${source.id}-${index}`,
        title: typeof title === 'string' ? title.trim() : '',
        description: typeof description === 'string' ? description.trim().slice(0, 500) : '',
        content: description,
        link: typeof link === 'string' ? link.trim() : '',
        pubDate,
        sourceId: source.id,
        sourceName: source.name,
        read: false,
      };
    }).filter((item: any) => item.title && item.link);

    return {
      source,
      items,
      lastBuildDate: channel.lastBuildDate || new Date().toISOString(),
    };
  } catch (error) {
    console.error(`è·å–RSSæº ${source.name} å¤±è´¥:`, error);
    return null;
  }
}

// è·å–æ‰€æœ‰è®¢é˜…æº
const sources = defaultRSSConfig.sources;

// ä»URLå‚æ•°è·å–é€‰ä¸­çš„æº
const selectedSource = Astro.url.searchParams.get('source') || 'all';
const forceRefresh = Astro.url.searchParams.get('refresh') === 'true';

// è·å–RSSæ•°æ®
let allFeeds: RSSFeed[] = [];
let totalArticles = 0;
let fetchError: string | null = null;
let fetchStats: any = {};
let fromCache = false;
let lastUpdateTime: string | null = null;

// è·å–æœ€åæ›´æ–°æ—¶é—´
try {
  if (redis) {
    const updateLog = await redis.get('rss-update-log');
    if (updateLog) {
      const logData = typeof updateLog === 'string' ? JSON.parse(updateLog) : updateLog;
      lastUpdateTime = logData.timestamp;
    }
  }
} catch (error) {
  console.error('è·å–æ›´æ–°æ—¥å¿—å¤±è´¥:', error);
}

try {
  const cacheKey = 'rss-all-feeds';
  
  // æ£€æŸ¥ç¼“å­˜ï¼ˆé™¤éå¼ºåˆ¶åˆ·æ–°ï¼‰
  if (!forceRefresh) {
    const cachedData = await getCachedData(cacheKey);
    if (cachedData) {
      allFeeds = cachedData.feeds || [];
      fetchStats = cachedData.stats || {};
      totalArticles = allFeeds.reduce((sum: number, feed: RSSFeed) => sum + feed.items.length, 0);
      fromCache = true;
      console.log('ä½¿ç”¨ç¼“å­˜çš„RSSæ•°æ®');
    }
  }
  
  // å¦‚æœæ²¡æœ‰ç¼“å­˜æˆ–å¼ºåˆ¶åˆ·æ–°ï¼Œå¹¶è¡Œè·å–æ‰€æœ‰æº
  if (!fromCache || forceRefresh) {
    console.log('å¹¶è¡Œè·å–RSSæº...');
    const startTime = Date.now();
    
    // ä½¿ç”¨ Promise.allSettled å¹¶è¡Œè·å–
    const promises = sources.map(source => fetchSingleSource(source));
    const results = await Promise.allSettled(promises);
    
    const errors: string[] = [];
    
    results.forEach((result, index) => {
      if (result.status === 'fulfilled' && result.value) {
        allFeeds.push(result.value);
      } else {
        const sourceName = sources[index]?.name || `æº ${index + 1}`;
        errors.push(`${sourceName}: è·å–å¤±è´¥`);
      }
    });
    
    totalArticles = allFeeds.reduce((sum: number, feed: RSSFeed) => sum + feed.items.length, 0);
    
    const duration = Date.now() - startTime;
    fetchStats = {
      total: sources.length,
      successful: allFeeds.length,
      failed: errors.length,
      duration,
      fromCache: false,
    };
    
    // ä¿å­˜åˆ°ç¼“å­˜
    const cacheData = {
      feeds: allFeeds,
      stats: fetchStats,
      timestamp: new Date().toISOString(),
    };
    await setCachedData(cacheKey, cacheData);
    
    console.log(`è·å–å®Œæˆï¼Œè€—æ—¶: ${duration}msï¼ŒæˆåŠŸ: ${allFeeds.length}/${sources.length}`);
  }
} catch (error) {
  fetchError = `è·å–RSSæ•°æ®æ—¶å‘ç”Ÿé”™è¯¯: ${error instanceof Error ? error.message : 'æœªçŸ¥é”™è¯¯'}`;
  console.error(fetchError);
}

const meta = {
  title: "RSSè®¢é˜…æº",
  description: "æµè§ˆæ¥è‡ªå¤šä¸ªæ¥æºçš„æœ€æ–°RSSè®¢é˜…å†…å®¹",
  ogImage: "/og-image.png"
};
---

<PageLayout meta={meta}>
  <section class="rss-page-header">
    <h1 class="title mb-6">RSSè®¢é˜…æº</h1>
    <p class="mb-8 text-lg text-gray-700 dark:text-gray-300 leading-relaxed">
      æ¢ç´¢æ¥è‡ªå¤šä¸ªä¼˜è´¨æ¥æºçš„æœ€æ–°å†…å®¹ï¼ŒåŒ…æ‹¬æŠ€æœ¯åšå®¢ã€æ–°é—»èµ„è®¯å’Œè¡Œä¸šåŠ¨æ€ã€‚
      æ‰€æœ‰å†…å®¹éƒ½ç»è¿‡ç²¾å¿ƒç­›é€‰ï¼Œä¸ºæ‚¨æä¾›æœ€æœ‰ä»·å€¼çš„ä¿¡æ¯ã€‚
    </p>

  <!-- è®¢é˜…æºç»Ÿè®¡ -->
  <div class="rss-stats mb-8">
    <!-- æœ€åæ›´æ–°æ—¶é—´ -->
    {lastUpdateTime && (
      <div class="rss-update-info">
        <span class="rss-update-label">ğŸ•’ æœ€åæ›´æ–°ï¼š</span>
        <span class="rss-update-time">
          {new Date(lastUpdateTime).toLocaleString('zh-CN', {
            timeZone: 'Asia/Shanghai',
            year: 'numeric',
            month: '2-digit',
            day: '2-digit',
            hour: '2-digit',
            minute: '2-digit',
            second: '2-digit',
            hour12: false
          })}
        </span>
        {fromCache && (
          <span class="rss-cache-badge">âœ“ ç¼“å­˜åŠ è½½</span>
        )}
      </div>
    )}
    
    <div class="grid grid-cols-1 sm:grid-cols-3 gap-6 mt-4">
        <div class="rss-stat-card">
          <div class="rss-stat-number text-3xl font-bold text-blue-600 dark:text-blue-400">
            {sources.length}
          </div>
          <div class="rss-stat-label text-gray-600 dark:text-gray-400">
            è®¢é˜…æº
          </div>
        </div>
        <div class="rss-stat-card">
          <div class="rss-stat-number text-3xl font-bold text-green-600 dark:text-green-400">
            {totalArticles}
          </div>
          <div class="rss-stat-label text-gray-600 dark:text-gray-400">
            æ€»æ–‡ç« æ•°
          </div>
        </div>
        <div class="rss-stat-card">
          <div class="rss-stat-number text-3xl font-bold text-purple-600 dark:text-purple-400">
            {sources.filter(source => source.isActive !== false).length}
          </div>
          <div class="rss-stat-label text-gray-600 dark:text-gray-400">
            æ´»è·ƒæº
          </div>
        </div>
      </div>
    </div>
  </section>

  <!-- RSSè®¢é˜…æºå†…å®¹ï¼ˆåˆ—è¡¨+åˆ†é¡µï¼‰ -->
  <section class="rss-feeds-section">
    <RSSFeedTable 
      sources={sources} 
      selectedSource={selectedSource} 
      itemsPerPage={15}
      currentPage={Number(Astro.url.searchParams.get('page') || '1')}
    />
  </section>

  <!-- é¡µé¢è¯´æ˜ -->
  <section class="rss-info-section mt-16">
    <div class="rss-info-card">
      <h3 class="text-lg font-semibold mb-4 text-gray-900 dark:text-white">
        å…³äºRSSè®¢é˜…æº
      </h3>
      <div class="grid grid-cols-1 md:grid-cols-2 gap-6 text-sm text-gray-600 dark:text-gray-400">
        <div>
          <h4 class="font-medium mb-2 text-gray-800 dark:text-gray-200">å®æ—¶æ›´æ–°</h4>
          <p>æ‰€æœ‰å†…å®¹éƒ½ä¼šå®æ—¶ä»åŸå§‹æ¥æºåŒæ­¥ï¼Œç¡®ä¿æ‚¨çœ‹åˆ°çš„æ˜¯æœ€æ–°ä¿¡æ¯ã€‚</p>
        </div>
        <div>
          <h4 class="font-medium mb-2 text-gray-800 dark:text-gray-200">å†…å®¹ç­›é€‰</h4>
          <p>æˆ‘ä»¬åªæ”¶å½•é«˜è´¨é‡ã€æœ‰ä»·å€¼çš„å†…å®¹æºï¼Œä¸ºæ‚¨èŠ‚çœæ—¶é—´ã€‚</p>
        </div>
        <div>
          <h4 class="font-medium mb-2 text-gray-800 dark:text-gray-200">å¤šæ ¼å¼æ”¯æŒ</h4>
          <p>æ”¯æŒå„ç§RSSæ ¼å¼ï¼ŒåŒ…æ‹¬RSS 2.0ã€Atomç­‰æ ‡å‡†æ ¼å¼ã€‚</p>
        </div>
        <div>
          <h4 class="font-medium mb-2 text-gray-800 dark:text-gray-200">ç¦»çº¿é˜…è¯»</h4>
          <p>å†…å®¹ä¼šç¼“å­˜åˆ°æœ¬åœ°ï¼Œæ”¯æŒç¦»çº¿é˜…è¯»ï¼Œæå‡è®¿é—®é€Ÿåº¦ã€‚</p>
        </div>
      </div>
    </div>
  </section>
</PageLayout>

<style>
  .rss-page-header {
    @apply mb-12;
  }

  .rss-stats {
    @apply mb-8;
  }

  .rss-stat-card {
    @apply bg-white dark:bg-gray-800 rounded-lg shadow-md p-6 text-center border border-gray-200 dark:border-gray-700;
  }

  .rss-stat-number {
    @apply mb-2;
  }

  .rss-stat-label {
    @apply text-sm font-medium;
  }

  .rss-feeds-section {
    @apply mb-12;
  }

  .rss-info-section {
    @apply border-t border-gray-200 dark:border-gray-700 pt-16;
  }

  .rss-info-card {
    @apply bg-gray-50 dark:bg-gray-800/50 rounded-lg p-8 border border-gray-200 dark:border-gray-700;
  }

  /* æ›´æ–°æ—¶é—´æ˜¾ç¤º */
  .rss-update-info {
    @apply bg-gradient-to-r from-blue-50 to-indigo-50 dark:from-gray-800 dark:to-gray-700 rounded-lg p-4 mb-6 flex items-center gap-3 shadow-sm border border-blue-100 dark:border-gray-600;
  }

  .rss-update-label {
    @apply text-gray-600 dark:text-gray-300 font-medium;
  }

  .rss-update-time {
    @apply text-gray-900 dark:text-white font-semibold;
  }

  .rss-cache-badge {
    @apply ml-auto bg-green-100 dark:bg-green-900 text-green-700 dark:text-green-300 px-3 py-1 rounded-full text-sm font-medium;
  }

  /* å“åº”å¼è®¾è®¡ */
  @media (max-width: 768px) {
    .rss-page-header .title {
      @apply text-2xl;
    }

    .rss-stats .grid {
      @apply grid-cols-1 gap-4;
    }

    .rss-info-card .grid {
      @apply grid-cols-1 gap-4;
    }
  }
</style>